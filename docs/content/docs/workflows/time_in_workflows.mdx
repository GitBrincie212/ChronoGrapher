---
title: Time In Workflows
description: Learn how to delay our Workflow and use timeouts
---

In our previous chapter, we have discussed the ``fallback`` primitive in extensive detail and how ordering matters in
ChronoGrapher's workflow model, in this chapter, we will be taking a look at ``timeout`` and ``delay``.

# Timeout Workflow Primitive
Our workflow currently has the issue of hanging.

Since Tasks can run for an infinite period of time, hanging is when we introduced something that waits around
for an unpredictable time (the perfect example are API requests), causing an accumulation of dead Tasks that wait around.

Waiting around for an unpredictable time might also indicate an error (perhaps an infinite while loop), making it
hard to notice this in production and highly dangerous. To solve this, use ``timeout``.

Back in our previous script, we add the following:
<RenderProgrammingLanguageBased target_name={"Rust"}>
```rust title="src/main.rs" lineNumbers=4
#[workflow(
    // [!code ++]
    timeout(5s),
    fallback(MyFallbackTaskFrame),
    retry(3, 2s)
)]
async fn APIRequestTask(ctx: &TaskContext) -> Result<(), MyErrors> {
    // <...>
}
```
</RenderProgrammingLanguageBased>

Try changing the timeout from 5s to something even lower such as ``2s``. Notice how it cancels the retry logic?

In real workflows, you usually want to account for per-retry delay when setting a timeout (e.g. 7s instead of 5s).
For demonstration purposes, we keep it lower to make the effect visible quickly.

Our terminal output may look something like this:
```zsh title="terminal"
# 1st run of Task (after 2 total seconds)
(Attempt: 0/3) Website responded with 500
(Attempt: 1/3) Website responded with 200 # AFTER 2 SECONDS

# 2nd run of Task (after 4 total seconds)
(Attempt: 0/3) Website responded with 200

# 3rd run of Task (after 6 total seconds)
(Attempt: 0/3) Website responded with 403
(Attempt: 1/3) Website responded with 403 # AFTER 2 SECONDS

# [!code --]
# (after 5 seconds of runtime) ERROR LEAKED THROUGH, CAUSING:
# [!code --]
Scheduler engine received an error for Task with identifier (...):
# [!code --]
    Task's runtime got timeout

# <...>
```

<RenderProgrammingLanguageBased target_name={"Rust"}>
    <Callout type={"error"} title={"Rust's Async Timeout Limitations"}>
        Timeouts in async Rust are cooperative, meaning they finish only when there is an async operation, more simply
        a task must reach an ``await`` point to be cancelled, any CPU-bound loops without ``await`` won't be interrupted.

        It is advised therefore to add periodic ``yield_now()`` calls. Learn more about in
        [Tokio's Documentation](https://docs.rs/tokio/latest/tokio/task/fn.yield_now.html)
    </Callout>
</RenderProgrammingLanguageBased>

Try switching the order! You can control where the timeout takes effect in. For our above example, it takes effect in
the entire workflow whereas in:
<RenderProgrammingLanguageBased target_name={"Rust"}>
```rust title="src/main.rs" lineNumbers=4
#[workflow(
    fallback(myfallback),
    retry(3, 2s),
    timeout(5s)
)]
```
</RenderProgrammingLanguageBased>
This only takes effect in business logic, another permutation is:
<RenderProgrammingLanguageBased target_name={"Rust"}>
```rust title="src/main.rs" lineNumbers=4
#[workflow(
    fallback(myfallback),
    retry(3, 2s),
    timeout(5s),
)]
async fn APIRequestTask(ctx: &TaskContext) -> Result<(), MyErrors> {
    // <...>
}
```
</RenderProgrammingLanguageBased>
Where once the business logic takes more than 5 seconds, a retry is automatically issued. The fallback may catch
the timeout error (if the retry logic didn't resolve it).

<Callout type={"error"} title={"Workflow Definitions Affect Error Structure"}>
    When changing the workflow definition of a Task (or TaskFrame), the underlying error representation also changes.
    One should always be careful of fallbacks, as in our previous example we used the type ``SharedFallbackError<MyErrors>``.

    Even for primitives such as ``retry`` or ``fallback`` which have errors originating from their nested ``TaskFrames``,
    they still wrap the error in a new type ``RetriableTaskFrameError`` and ``FallbackTaskFrameError`` respectively.

    The reason for this has to do with debugging and detailed error introspection. By wrapping via new types,
    users handling the error know how the workflow reacted to the error.

    However this will be explained in-depth in the next chapter.
</Callout>

Generally, use timeouts when you want to limit the execution time of a workflow part (prevents hanging). It is advised
therefore to run multiple times the workflow and see the average time, then use that.

When it comes to deciding which layer to use the timeout. If you want to bound the entire workflow to finish at a specific
duration, layer it on top.

The inverse applies as well for layering it at the bottom, when you want to enforce it on one part.

# Workflow Delays In Depth
We may want to delay the execution of part of our workflow or the entire (though the latter is much more rare)
by a specified duration.

We can use ``delay`` to achieve our goals. Like so:
<RenderProgrammingLanguageBased target_name={"Rust"}>
```rust title="src/main.rs" lineNumbers=4
#[workflow(
    timeout(6s),
    fallback(myfallback),
    delay(500ms),
    retry(3, 2s),
)]
async fn APIRequestTask(ctx: &TaskContext) -> Result<(), MyErrors> {
    // <...>
}
```
</RenderProgrammingLanguageBased>

> Do note from our previous callout, even if delay doesn't error on its own, it still includes a ``DelayTaskFrameError<...>``.

In our case we apply the ``delay`` in the retry logic that encapsulates the business logic, and we delay it by ``500ms``.

Generally ``delay`` is less of a common workflow primitive to use. Its use is only for delaying certain workflow
parts by a constant duration.

To wrap things up, ``timeout`` should be used to enforce a time limit for the runtime of a workflow part. Depending
on the circumstance, it is better to lay it on top of the workflow to enforce a global execution limit.

Or alternatively, if a part requires a time limit, it is better to lay it on top of that part and not at the complete top.
As far as it goes for ``delay``, it is used only for delaying some parts by a specified constant duration.

In the next chapter, we will discuss more in-depth about error handling and various best practices about it.

> TL;DR. ``timeout`` is used for enforcing a time limit for part of our workflow (or the entire thing). Layer it on
top of the workflow to enforce a global time limit, Layer it on a specific part to enforce a time limit only there.
``delay`` is less common but used for delaying by a constant time some workflow parts.