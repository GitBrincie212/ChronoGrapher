---
title: Fallback Patterns & Usage
description: Learn when and how to use fallbacks, the nuances of workflow ordering and common patterns
---

In the previous chapter, we were introduced to ChronoGrapher's workflow model by discussing some of the basics
about retries and when to use.

However, coming back to our current script and modifying it slightly to introduce a new status code:
<RenderProgrammingLanguageBased target_name={"Rust"}>
```rust title="src/main.rs" lineNumbers
use chronographer::prelude::*;
use thiserror::Error;

#[derive(Error, Debug)]
pub enum MyErrors {
    // <...>

    // [!code ++]
    #[error("Forbidden access regarding our web page")]
    // [!code ++]
    ForbiddenAccessError,

    // <...>
}

#[task(interval(2s))]
#[workflow(retry(3, 2s))]
async fn APIRequestTask(ctx: &TaskContext) -> Result<(), MyErrors> {
    // [!code highlight]
    let res = reqwest::get("https://httpbin.org/status/200,429,500,403").await?;

    // <...>

    // In real code, you would describe in more detail the errors
    match res.status() {
        // [!code ++]
        403 => Err(MyErrors::ForbiddenAccessError), // Cannot be resolved with retries

        // <...>
    }
}

// <...>
```
</RenderProgrammingLanguageBased>
You may notice how when we added the 403 status code, it presents us with a new problem, the fact this kind of error
can't be resolved by our retry logic, which presents us with the possibility, the error will leak through.

# Using Fallbacks

To fix this issue, we can use **Fallbacks**. They allow us to execute a backup ``TaskFrame`` when the main one fails,
in our case we can wire one like so:
<RenderProgrammingLanguageBased target_name={"Rust"}>
```rust title="src/main.rs" lineNumbers=4
// <...>

// [!code ++]
#[taskframe]
// [!code ++]
async fn MyFallbackTaskFrame(ctx: &TaskContext) -> Result<(), MyErrors> {
    // [!code ++]
    if let Some(error) = ctx.get_shared::<SharedFallbackError<MyErrors>>().await {
        // [!code ++]
        // In real-world scenarios you handle these errors more gracefully
        // [!code ++]
        return match error.0 {
            // [!code ++]
            // We can safely ignore, as its just too many requests and not an actual error
            // [!code ++]
            MyErrors::TooManyRequests => Ok(()),
            // [!code ++]

            // [!code ++]
            // Server errors are an error worth addressing
            // [!code ++]
            MyErrors::ServerError => {
                // [!code ++]
                println!("Handling Server-Related Error Via Fallback");
                // [!code ++]
                // <...Handling Process...>
                // [!code ++]
                Ok(())
            // [!code ++]
            },
            // [!code ++]

            // [!code ++]
            MyErrors::ForbiddenAccessError => {
                // [!code ++]
                println!("Handling Forbidden Access Error Via Fallback");
                // [!code ++]
                // <...Different Handling Process...>
                // [!code ++]
                Ok(())
            // [!code ++]
            },
            // [!code ++]

            // [!code ++]
            // An error which we can't handle, leak it through
            // [!code ++]
            err => {
                // [!code ++]
                println!("Cannot Handle This Error Via Fallback");
                // [!code ++]
                Err(err)
            // [!code ++]
            }
        // [!code ++]
        };
    // [!code ++]
    }
    // [!code ++]
    Ok(())
// [!code ++]
}

#[task(interval(2s))]
#[workflow(
    // [!code ++]
    fallback(MyFallbackTaskFrame),
    retry(3, 2s)
)]
async fn APIRequestTask(ctx: &TaskContext) -> Result<(), MyErrors> {
    // <...>
}
```
</RenderProgrammingLanguageBased>
When a fallback is executed. ChronoGrapher stores the error that ``APIRequestTask`` threw, this way the fallback can
access it via ``get_shared``, this method is a part of a bigger API which is explained in later chapters.

Now when our code runs, in a realistic environment we may see:
```zsh title="terminal"
# 1st run of Task (after 2 total seconds)
(Attempt: 0/3) Website responded with 403
(Attempt: 1/3) Website responded with 403 # AFTER 2 SECONDS
(Attempt: 2/3) Website responded with 403 # AFTER 2 SECONDS
(Attempt: 3/3) Website responded with 403 # AFTER 2 SECONDS

Handling Forbidden Access Error Via Fallback

# <...>
```
Try to lower the number of retries to see it in effect.

> It should be noted: In real systems, fallbacks usually perform more graceful handling
(logging or compensating actions). Here we keep it simple.

<Callout type={"idea"} title={"Clever Retrying"}>
    The status code ``403`` usually indicates an issue with the permissions you have, so retrying it is often redundant.
    A pro tip is to use the ``when`` parameter on retries which is covered in a later chapter.
</Callout>

Since our fallback is a ``TaskFrame``, we can also lay on top its own workflow definition, though this is best
spared for advanced patterns in the next following chapters.

Try to move the fallback below the retry like so:
<RenderProgrammingLanguageBased target_name={"Rust"}>
```rust title="src/main.rs" lineNumbers=4
#[workflow(
    retry(3, 2s),
    fallback(MyFallbackTaskFrame)
)]
async fn APIRequestTask(ctx: &TaskContext) -> Result<(), MyErrors> {
    // <...>
}
```
</RenderProgrammingLanguageBased>
You may notice something interesting, the output of the workflow is completely different, all by re-ordering
two primitives.

Try adding a new error variant for the status code ``300``, but do not handle it in the fallback. By doing this,
you may notice how significantly the output changes:
```zsh title="terminal"
# 1st run of Task (after 2 total seconds)
(Attempt: 0/3) Website responded with 500
Handling Server-Related Error Via Fallback

# 2nd run of Task (after 4 total seconds)
(Attempt: 0/3) Website responded with 403
Handling Forbidden Access Error Via Fallback

# 3rd run of Task (after 6 total seconds)
(Attempt: 0/3) Website responded with 200

# 4th run of Task (after 8 total seconds)
(Attempt: 0/3) Website responded with 300
Cannot Handle This Error Via Fallback

(Attempt: 1/3) Website responded with 300
Cannot Handle This Error Via Fallback

(Attempt: 2/3) Website responded with 300
Cannot Handle This Error Via Fallback

(Attempt: 3/3) Website responded with 300
Cannot Handle This Error Via Fallback

# <...>
```

# Workflow Order Matters

This is one of the more subtle things about ChronoGrapher's workflow model. **<u>The order of workflow primitives MATTERS</u>**,
to illustrate this better we can look how each of these executes.

The original workflow's execution semantics are described as:
> retry → fallback: Try 3 times, if still failing, run fallback

The modified workflow's execution semantics differ by:
> fallback → retry: Run fallback on error, retry the entire thing if the fallback and primary logic fail

Generally, a rule of thumb to keep in mind is anything on top, encapsulates everything below it. To put it more bluntly,
the top workflow primitive executes first whereas the bottom one executes last.

---

So when should you use fallbacks? Generally, you should use them commonly for handling recoverable errors gracefully from
workflow parts, this allows you to split the error handling logic from business logic.

When it comes to the patterns, the "retries with outer fallback" should be used when there are non-transient errors,
the "retries with inner fallback" should be used for errors that are immediately resolvable.

Which will lead us to the next chapter, we will be discussing more about ``timeout`` and ``delay``, how they are useful
for expressing control flow with time as their parameter and how to assemble a basic workflow.

> TL;DR. Fallbacks are a workflow primitive which defines a backup ``TaskFrame`` to execute when the primary logic fails with
an error, the job of the backup is to handle the error gracefully. Fallbacks can be chained with retries, but the ordering
of which matters heavily.