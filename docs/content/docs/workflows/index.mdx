---
title: Handling Failure
description: Learn why handle failure and why its critical and how ChronoGrapher solves it
optional: true
---

We have discussed in the previous chapter how to set up a "Hello ChronoGrapher" script. However, real-world codebases
deal with multiple failure points, such as database operations, API requests and so on.

For demonstrative purposes, we will use a simple script that approximates real-world behavior, let's modify our previous script
to simulate this kind of failure:
<RenderProgrammingLanguageBased target_name={"Rust"}>
```rust title="src/main.rs" lineNumbers
use chronographer::prelude::*;
use thiserror::Error;

// [!code highlight]
// Install the "reqwest" crate

#[derive(Error, Debug)]
pub enum MyErrors {
    // [!code ++]
    #[error("Request failed via {0}")]
    // [!code ++]
    RequestFailed(#[from] reqwest::Error),
    // [!code ++]

    // [!code ++]
    #[error("Too many requests present in our web page")]
    // [!code ++]
    TooManyRequests,
    // [!code ++]

    // [!code ++]
    #[error("Server error regarding our web page")]
    // [!code ++]
    ServerError,
    // [!code ++]

    // [!code ++]
    #[error("Error with different HTTP status code of \"{0}\"")]
    // [!code ++]
    OtherHttpStatus(reqwest::StatusCode)
}

#[task(interval(3s))]
async fn APIRequestTask(ctx: &TaskContext) -> Result<(), MyErrors> {
    // [!code ++]
    let res = reqwest::get("https://httpbin.org/status/200,429,500").await?;

    // [!code ++]
    // For demonstration purposes
    // [!code ++]
    println!("Website responded with {}", res.status());

    // [!code ++]
    // In real code, you would provide more rich errors
    // [!code ++]
    match res.status() {
        // [!code ++]
        200 => Ok(()),
        // [!code ++]
        429 => Err(MyErrors::TooManyRequests),
        // [!code ++]
        500 => Err(MyErrors::ServerError),
        // [!code ++]
        _ => Err(MyErrors::OtherHttpStatus(res.status())),
    // [!code ++]
    }
}

#[chronographer::main]
async fn main(scheduler: DefaultScheduler<MyErrors>) {
    let task_inst = APIRequestTask::instance();
    let _ = scheduler.schedule(task_inst).await;
}
```
</RenderProgrammingLanguageBased>
We have filled the ``MyErrors`` enum with our own errors which we expect, as well as making a Task that does an API
request to some service (in our case ``httpbin`` for demonstrative purposes).

While in typical API requests we expect more status codes which we have to handle gracefully, in our case we expect only
three, those being ``200`` for success, ``429`` for too many requests and ``500`` for a server error.

In real systems these failures aren’t truly random. They usually depend on load, rate limits, outages, or network
issues, but from the client side they may appear so.

Keep in mind this code is here for demonstrative purposes, the idea is to get a grasp on how approximately things are
handled in the real-world when it comes to using ChronoGrapher.

Running the above code yields us something similar to:
```zsh title="terminal"
# 1st run of Task (after 2 total seconds)
[DEBUG] Website responded with 200

# 2nd run of Task (after 4 total seconds)
Website responded with 429

# [!code --]
# ERROR LEAKED THROUGH, CAUSING:
# [!code --]
Scheduler engine received an error for Task with identifier (...):
# [!code --]
Too many requests present in our web page

# <...>
```
> The error leakage message may vary depending on the error.

# The Problem Space

Since we have introduced potential failure, one question that arises is
> What Happens When Failure Leaks Through The Task?

The answer is more nuanced than it seems **depending on the Scheduler**. In our case with ``DefaultScheduler``,
when a Task fails, it prints the error and fully terminates said Task.

More specifically, by termination it means the ``Task`` is never rescheduled and is outright removed from the ``DefaultScheduler``.
This behavior is intentional and specific to this scheduler, production schedulers handle this differently.

This is usually not an intended behavior, as such caution is required to minimize failures. Solving this problem fully
is impossible, as failures can **and SHOULD** leak through the task.

The obvious question to ask is:
> **What solutions do we have to mitigate this problem?**

There are plenty of ways other frameworks solve this problem with their own approaches and tradeoffs. We will briefly discuss
some of the obvious ones and show how ChronoGrapher handles the problem.

## Solution 1: Manual Patterns
In utilities such as cron, this is the expected way of handling most stuff. The Scheduler there is dumb and has one responsibility,
the developer tries to patch the errors themselves.

Which leads simple cases such as retrying our code 5 times, to involve heavy boilerplate code, encouraging a non-reusable:
<RenderProgrammingLanguageBased target_name={"Rust"}>
```rust title="src/main.rs" lineNumbers
use chronographer::prelude::*;
use thiserror::Error;
use tokio::time::{sleep, Duration};

// <...>

#[task(interval(2s))]
async fn APIRequestTask(ctx: &TaskContext) -> Result<(), MyErrors> {
    // [!code ++]
    let mut final_res: Result<(), MyErrors> = Ok(());
    // [!code ++]
    for _ in 0..=5 {
        let res = reqwest::get("https://httpbin.org/status/200,429,500").await?;

        // For demonstration purposes
        println!("Website responded with {}", res.status());

        // In real code, you would provide more rich errors
        final_res = match res.status() {
            200 => Ok(()),
            429 => Err(MyErrors::TooManyRequests),
            500 => Err(MyErrors::ServerError),
            _ => Err(MyErrors::OtherHttpStatus(res.status())),
        };
        // [!code ++]

        // [!code ++]
        if final_res.is_ok() {
            // [!code ++]
            break;
        // [!code ++]
        }

        // [!code ++]
        sleep(Duration::from_millis(500)).await; // Delay in-between
    // [!code ++]
    }

    // [!code ++]
    match final_res {
        // [!code ++]
        Ok(()) => Ok(())
        // [!code ++]
        Err(res) => {
            // [!code ++]
            // ...Tries to address the error via a fallback...
        // [!code ++]
        }
    // [!code ++]
    }
    // [!code ++]
    final_res
}

// <...>
```
</RenderProgrammingLanguageBased>

In our simple example, it doesn't do much. However, imagine now 10 different failure points, each requiring a retry plus
a fallback. To top it all off, we may need to add another fallback for safety. This approach in turn scales poorly as:

- You introduce massive maintenance burden for every Task you create.
- Outside developers have to understand how <u>you</u> implement retries, fallbacks.
- One mistake costing hours to find one simple bug in retry logic and fallback logic.
- Want to make retries/fallbacks more powerful? Good luck, you have to change the entire codebase or write your own complementary logic.

In exchange, you get:
- Control over the order of operations
- Fully explicit logic

Far from ideal, to address this problem, libraries often provide these basic utilities. Which leads us to the second solution.

## Solution 2: Fixed Provided Patterns
Suppose a hypothetical (but realistic) scheduling library, they provide utilities such as retries and fallbacks in the form
presented below:
<RenderProgrammingLanguageBased target_name={"Rust"}>
```rust title="src/main.rs" lineNumbers
use hypothetical_schedule_lib::prelude::*;
use thiserror::Error;

// <...>
// This is theoretical code (which doesn't run)

#[task(
    schedule = interval(2s),
    // [!code ++]
    retry_count = 10,
    // [!code ++]
    retry_delay = 500ms,
    // [!code ++]
    fallback = other_task_fallback
)]
async fn APIRequestTask(ctx: &TaskContext) -> Result<(), MyErrors> {
    let res = reqwest::get("https://httpbin.org/status/200,429,500").await?;

    // For demonstration purposes
    println!("Website responded with {}", res.status());

    // In real code, you would provide more rich errors
    match res.status() {
        200 => Ok(()),
        429 => Err(MyErrors::TooManyRequests),
        500 => Err(MyErrors::ServerError),
        _ => Err(MyErrors::OtherHttpStatus(res.status())),
    }
}

// <...>
```
</RenderProgrammingLanguageBased>

This approach is more of a bandage solution to the problem. While developers won't have to reinvent the wheel
(retries, fallbacks) with this approach, new problems arise:
- The ordering of retries and fallbacks is pinned.
- If developers want more, they have to tweak the library themselves or find other hacky ways.
- The design is opinionated in how you manage fallbacks and retries.

Overall, this approach can be significantly improved. Which leads us to how ChronoGrapher handles this, and how it marries
these 2 solutions as one, while keeping each's strengths and minimizing weaknesses.

# The ChronoGrapher Way
ChronoGrapher's solution marries the strengths of the two previously mentioned solutions (manual boilerplate
and fixed library-provided utilities), by introducing a different model to think about workflows.

Instead of thinking workflows have fixed retries, fixed fallbacks, ChronoGrapher models workflows with **TaskFrames**,
While we previously described TaskFrames as "just execution blocks", that’s only part of the story.

**Workflow Primitives** they are simple ``TaskFrame`` single-responsible objects which wrap other ``TaskFrames``,
they execute additional code on top of the wrapped ``TaskFrame``.

The power comes by chaining multiple types of these Workflow Primitives in a declarative way. Each simple workflow
primitive works in harmony with other ones to produce something more complex.

<u>Think of them as "Russian Stacking Dolls"</u>. Each doll has its own responsibility, it does one and only thing very well,
and by stacking multiple of these together, you can assemble an entire workflow.

With the theory aside, we can move to the next chapter which discusses in detail how to use basic workflow primitives.
Some of these include using ChronoGrapher's ``retries``, ``fallback`` and how workflow ordering matters now.
<RenderProgrammingLanguageBased target_name={"Rust"}>
```rust title="src/main.rs" lineNumbers
#[task(interval(2s))]
#[workflow(retry(5, 2s))]
async fn APIRequestTask(ctx: &TaskContext) -> Result<(), MyErrors> {
    // <...>
}
```
</RenderProgrammingLanguageBased>

> TL;DR. Handling failure in scheduling is a challenge. Solutions such as manual boilerplate or library-defined fixed
mechanisms are brittle. ChronoGrapher marries these solutions while keeping their strengths intact.
To achieve this it uses its own workflow model (simple primitives → complex workflows)