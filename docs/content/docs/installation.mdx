---
title: Installation & Theory
description: Setting up and running ChronoGrapher, while discussing some theory
---

Installation is as simple as creating a new project in <ProgrammingLanguage />, installing the
ChronoGrapher package in <ProgrammingLanguage /> and setting up a "Hello World" script. We will
also be discussing in parallel the scheduling theory of ChronoGrapher

# Setting Up The Project

<RenderProgrammingLanguageBased target_name={"Rust"}>
Setup a Cargo project by running the command (on any OS):
```zsh title="terminal"
cargo new hello_chronographer
cd hello_chronographer
```
then install the package either by embedding it directly in the ``Cargo.toml`` file:
```toml title="Cargo.toml"
[package]
name = "hello_chronographer"
version = "0.1.0"
edition = "2024"

[dependencies]
chronographer = "0.0.1a"
```
or by simply running the command:
```zsh title="terminal"
cargo add chronographer
```

We recommend installing [anyhow](https://docs.rs/anyhow/latest/) or [thiserror](https://docs.rs/thiserror/latest/) alongside,
this allows for better error handling, simply run ``cargo add anyhow`` or ``cargo add thiserror`` to install the respective
crate.

For simple use cases, we will be using ``anyhow``, however these concepts should transfer over for Rust users using
the ``thiserror`` or any other crate or utility for error handling.

# The "Hello ChronoGrapher" Script
Navigate to the ``src/main.rs`` file, then rewrite it with the code:
```rust title="src/main.rs" lineNumbers
use chronographer::prelude::*;

#[task(schedule = interval(2s))]
async fn MyTask(ctx: &TaskContext) -> Result<(), TaskError> {
    println!("Hello ChronoGrapher!");
    Ok(())
}

#[chronographer::main]
async fn main(scheduler: DefaultAnyhowScheduler) {
    let task_inst = MyTask::instance();
    let _ = scheduler.schedule(task_inst).await;
}
```
Now you can run the code via:
```zsh title="terminal"
cargo run
# 1.5s after the run -> "Hello ChronoGrapher!"
# 3.0s after the run -> "Hello ChronoGrapher!"
# ...
```
</RenderProgrammingLanguageBased>
You should notice a "Hello World" printed every 1.5 seconds. Congratulations, that is your basic "Hello ChronoGrapher!" script
written in <ProgrammingLanguage />. While it was simple, let us step back and ask the bigger question "What's going on exactly?".

To answer this question. We have to introduce two areas which ChronoGrapher separates from us, these being
<Highlight color={"info"}>Schedulers</Highlight> and <Highlight color={"error"}>Tasks</Highlight>.

For now, we will mainly be discussing about ``Tasks`` since it is a daily occurrence to interact with,
in the future we will dive into ``Schedulers`` as well.

<RenderProgrammingLanguageBased target_name={"Rust"}>
<Callout type={"info"} title={"The \"scheduler\" argument"}>
    The scheduler argument can have any kind of name and any ``Scheduler`` type. Though there are additional constraints on
    what ``Scheduler`` type is allowed which we will discuss later.

    However, more importantly, note ``DefaultAnyhowScheduler`` is a type alias to a ``Scheduler`` with configurations
    for working with ``anyhow``.
</Callout>
</RenderProgrammingLanguageBased>
<br />
# What Are Tasks?
Tasks contain the <Highlight color={"success"}>Execution Logic</Highlight> and <Highlight color={"neutral"}>Scheduling Logic</Highlight>,
the former is **the code we want to run**, which can be database operations, API requests, mantainence and other computation.

While the latter **dictates at what date should the Task run**, more specifically given a current time,
we want to find the future time. Both cannot interfere with the other.

This makes it possible to define different Tasks that have the same execution logic (code) to run but a
different scheduling algorithm or vice versa (it allows reusability, no need to rewrite lots of parts).

In our example we can clearly identify the execution logic is the code inside the async function:

<RenderProgrammingLanguageBased target_name={"Rust"}>
```rust title="src/main.rs" lineNumbers
#[task(schedule = interval(2s))]
async fn MyTask(ctx: &TaskContext) -> Result<(), TaskError> {
    // [!code focus]
    println!("Hello ChronoGrapher!");
    // [!code focus]
    Ok(())
}
```
We can also identify where the scheduling logic is via (the interval = 1.5s more specifically):
```rust title="src/main.rs" lineNumbers
// [!code focus]
#[task(schedule = interval(2s))]
async fn MyTask(ctx: &TaskContext) -> Result<(), TaskError> {
    println!("Hello ChronoGrapher!");
    Ok(())
}
```
Try changing the interval from 1.5s to something else (such as 3s) and notice what happens.
</RenderProgrammingLanguageBased>

In ChronoGrapher, the Execution Logic part are ``TaskFrames`` components and the Scheduling Logic are ``TaskSchedules``
components (the macro somewhat hides them for ergonomics).
<Callout type={"info"} title={"Regarding The TaskSchedules"}>
    TaskSchedules are a smaller but more common part of a larger system called ``TaskTriggers``. While ``TaskSchedules``
    are themselves ``TaskTriggers``, their are semantics different (we will dive in detail, in the near future about them).
</Callout>

A Task itself is useless, we have to also **Schedule** it.
<RenderProgrammingLanguageBased target_name={"Rust"}>Which is where the main function comes in:</RenderProgrammingLanguageBased>
<RenderProgrammingLanguageBased target_name={"Rust"}>
```rust title="src/main.rs" lineNumbers
#[chronographer::main]
async fn main(scheduler: DefaultAnyhowScheduler) {
    // [!code highlight]
    let task_inst = MyTask::instance();
    // [!code highlight]
    let _ = scheduler.schedule(task_inst).await;
}
```
</RenderProgrammingLanguageBased>
We spawn an instance of that Task and simply hand it out to the scheduler via the ``schedule`` method.

A summary of how Tasks work, can be boiled down with this diagram:
<ThemeBasedImage
    light={"/diagram-light-2.svg"} dark={"/diagram-dark-2.svg"}
    width={1200} height={1200}
    alt={"Diagram of Task's layout and communication between the Scheduler"}
/>
Where a Task has 2 separate parts (Execution Logic, Scheduling Logic). Then the Task interacts with the ``Scheduler``
to schedule at a specific time(more specifically execute at **9:00 AM**).

Once the time is reached, our Scheduler alerts our Task **to start executing the logic**, then once our
Task finished, it alerts the Scheduler that it wants to schedule again, repeating this cycle.

For the Scheduler side, we will be discussing this in future chapters, we will however, discuss how to make tasks reliable.
> TL;DR. We set up a new project in <ProgrammingLanguage /> utilizing ChronoGrapher, and ran a simple "Hello World"
example. Tasks are composed of TaskFrames (execution logic), TaskSchedules (scheduling logic),
keeping logic and scheduling separate for reuse and flexibility.