---
title: Installation & Theory
description: Setting up and running ChronoGrapher, while discussing some theory
---

Installation is as simple as creating a new project in <ProgrammingLanguage />, installing the
ChronoGrapher package in <ProgrammingLanguage /> and setting up a "Hello World" script. We will
also be discussing in parallel the scheduling theory of ChronoGrapher

# Setting Up The Project

<RenderProgrammingLanguageBased target_name={"Rust"}>
Setup a Cargo project by running the command (on any OS):
```zsh title="terminal"
cargo new hello_chronographer
cd hello_chronographer
```
then install the package either by embedding it directly in the ``Cargo.toml`` file:
```toml title="Cargo.toml"
[package]
name = "hello_chronographer"
version = "0.1.0"
edition = "2024"

[dependencies]
chronographer = "0.0.1a"
```
or by simply running the command:
```zsh title="terminal"
cargo add chronographer
```

# The "Hello ChronoGrapher" Script
Navigate to the ``src/main.rs`` file, then rewrite it with the code:
```rust title="src/main.rs" lineNumbers
use chronographer::prelude::*;

#[task(interval = 1.5s)]
async fn mytask(ctx: &TaskContext) -> Result<(), TaskError> {
    println!("Hello ChronoGrapher!");
    Ok(())
}

#[chronographer::main]
async fn main() {
    let task_inst = mytask();
    let _ = CHRONOGRAPHER_SCHEDULER.schedule(task_inst).await;
}
```
Now you can run the code via:
```zsh title="terminal"
cargo run
# 1.5s after the run -> "Hello ChronoGrapher!"
# 3.0s after the run -> "Hello ChronoGrapher!"
# ...
```
</RenderProgrammingLanguageBased>
You should notice a "Hello World" printed every 1.5 seconds. Congratulations, that is your basic "Hello ChronoGrapher!" script
written in <ProgrammingLanguage />. While it was simple, let us step back and ask the bigger question "What's going on exactly?".

To answer this question. We have to introduce two areas which ChronoGrapher separates from us, these being
<Highlight color={"info"}>Schedulers</Highlight> and <Highlight color={"error"}>Tasks</Highlight>.

For now, we will mainly be discussing about ``Tasks`` since it is a daily occurrence to interact with,
in the future we will dive into ``Schedulers`` as well.

---

# What Are Tasks?
Tasks contain the <Highlight color={"success"}>Business Logic</Highlight> and <Highlight color={"neutral"}>Scheduling Logic</Highlight>,
the former is **the code we want to run**, which can be database operations, API requests, mantainence and other computation.

While the latter **dictates at what date should the Task run**, more specifically given a current time,
we want to find the future time.

Additionally, Tasks contain a **Scheduling Policy** to define how should they run exactly (not as important to understand).
These parts are separate and distant but critical to create a Task.

The business logic cannot interfere with the scheduling logic and vice versa.

This makes it possible to define different Tasks that have the same business logic (code) to run but a
different scheduling algorithm or vice versa (it allows reusability, no need to rewrite lots of parts).

In our example we can clearly identify the business logic is the code inside the async function:

<RenderProgrammingLanguageBased target_name={"Rust"}>
```rust title="src/main.rs" lineNumbers
#[task(interval = 1.5s)]
async fn mytask(ctx: &TaskContext) -> Result<(), TaskError> {
    // [!code focus]
    println!("Hello ChronoGrapher!");
    // [!code focus]
    Ok(())
}
```
We can also identify where the scheduling logic is via (the interval = 1.5s more specifically):
```rust title="src/main.rs" lineNumbers
// [!code focus]
#[task(interval = 1.5s)]
async fn mytask(ctx: &TaskContext) -> Result<(), TaskError> {
    println!("Hello ChronoGrapher!");
    Ok(())
}
```
Try changing the interval from 1.5s to something else (such as 3s) and notice what happens.
</RenderProgrammingLanguageBased>

In ChronoGrapher, the Business Logic part are ``TaskFrames`` components and the Scheduling Logic are ``TaskSchedules``
components (the macro somewhat hides them for ergonomics).
<Callout type={"info"} title={"Regarding The TaskSchedules"}>
    TaskSchedules are a smaller but more common part of a larger system called ``TaskTriggers``. While ``TaskSchedules``
    are themselves ``TaskTriggers``, their are semantics different (we will dive in detail, in the near future about them).
</Callout>

A Task itself is useless, we have to also **Schedule** it. <RenderProgrammingLanguageBased target_name={"Rust"}>Which is where the main function comes in:</RenderProgrammingLanguageBased>
<RenderProgrammingLanguageBased target_name={"Rust"}>
```rust title="src/main.rs" lineNumbers
#[chronographer::main]
async fn main() {
    // [!code highlight]
    let task_inst = mytask();
    // [!code highlight]
    let _ = CHRONOGRAPHER_SCHEDULER.schedule(task_inst).await;
}
```
</RenderProgrammingLanguageBased>
We spawn an instance of that Task and simply hand it out to the scheduler via the ``schedule`` method present in the
``CHRONOGRAPHER_SCHEDULER`` global.
<Callout type={"warning"} title={"Disclaimer About The CHRONOGRAPHER_SCHEDULER Global"}>
    ``CHRONOGRAPHER_SCHEDULER`` is **NOT meant to be used in production**, it is a simple default scheduler.

    This is used for demonstrative purposes and learning more about ChronoGrapher's Tasks which are universal and
    don't have to do with how the Scheduler itself is configured.

    We will learn how to create our own Scheduler in the next chapters, however, in the meantime we will be using
    ``CHRONOGRAPHER_SCHEDULER`` as its prebuilt and intended for our case, but keep this disclaimer in mind.

    <RenderProgrammingLanguageBased target_name="Rust">
        Additionally, it should be mentioned the schedule method returns a ``Result`` back, which means it can
        succeed but can also fail. Therefore, in most cases, developers should gracefully handle any errors from scheduling tasks.

        For demonstration purposes and simplicity we silently ignore it, this should never be done under any circumstances
        in any real-world code.
    </RenderProgrammingLanguageBased>
</Callout>

A summary of how Tasks can be boiled down with this diagram:
<ThemeBasedImage
    light={"/diagram-light-2.svg"} dark={"/diagram-dark-2.svg"}
    width={1200} height={1200}
/>
Where a Task has 3 separate parts (Business Logic, Scheduling Logic and Scheduling Policy). Then the Task is scheduled
on the global ``CHRONOGRAPHER_SCHEDULER`` to execute at **9:00 AM**.

Once the time is reached, ``CHRONOGRAPHER_SCHEDULER`` alerts our Task **to start executing the business logic**. For
the Scheduler side, we will be discussing this in future chapters, we will however, discuss how to make tasks reliable.
> TL;DR. We set up a new project in <ProgrammingLanguage /> utilizing ChronoGrapher, and ran a simple "Hello World"
example. Tasks are composed of TaskFrames (business logic), TaskSchedules (scheduling logic), and a Scheduling Policy,
keeping logic and scheduling separate for reuse and flexibility.