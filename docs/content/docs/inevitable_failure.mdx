---
title: Inevitable Failure & Its Problems
description: Description on how inevitable failure can happen, ways to mitigate and workflows
---
So far, in the previous chapter we've scheduled work which always succeeds as seen in our "Hello ChronoGrapher" script,
while this was great for learning the basics, real-world code is rarely this simple.

Thus, let's introduce a more "realistic" scenario via a new Task (where the function is a TaskFrame). In the way
explaining the major pain points we encounter and how ChronoGrapher tackles this problem:
<RenderProgrammingLanguageBased target_name={"Rust"}>
```rust title="src/main.rs" lineNumbers
use chronographer::prelude::*;
// [!code ++]
use std::sync::Arc;
// [!code ++]
use rand::prelude::*;

// [!code highlight]
// Add the "rand" crate to Cargo.toml (with thread_rng feature)

// [!code ++]
#[task(interval = 3s)]
async fn mytask(ctx: &TaskContext) -> Result<(), TaskError> {
    // [!code ++]
    println!("Simulating real-world complex unpredictable logic");
    // [!code ++]
    let mut rng = rand::thread_rng();
    // [!code ++]
    if rng.gen() <= 0.8 {
        // [!code ++]
        return Err(Arc::new("Complex real-world logic failed"));
    // [!code ++]
    }
    Ok(())
}

#[chronographer::main]
async fn main() {
    let task_inst = mytask();
    CHRONOGRAPHER_SCHEDULER.schedule(task_inst).await;
}
```
</RenderProgrammingLanguageBased>

# The Problem Space

<Callout type={"info"} title={"About The Script"}>
This script is used to **simulate unpredictable failure (80% of the time)** for our purposes of explaining the problem.
Real-world code has more complex logic with multiple failure points which can fail at any time.
</Callout>

One question we haven't discussed is:
> **"When tasks fail, how are they handled?"**

The answer is more nuanced than it seems **depending on the Scheduler** (will be elaborated in future chapters from the Scheduler
side). When a task fails in ``CHRONOGRAPHER_SCHEDULER``, it panics and fully terminates. This behavior is intentional and specific to
this demo scheduler.

This is usually not an intended behavior, as such caution is required to minimize failures. Solving this problem fully
is impossible, as failures can **and SHOULD** (foreshadowing) leak through the task.

The obvious question to ask is:
> **What solutions do we have to mitigate this problem?**

There are plenty of ways other frameworks solve this problem with their own approaches and tradeoffs. We will discuss some
of the obvious ones and show how ChronoGrapher handles the problem.

# Silently Ignoring Errors (Solution 1)
The approach is to treat every failure as a success, this involves removing any errors and mapping them to a success. While
at the same time guarantee failures are never present, however, this presents a major flaw:
<RenderProgrammingLanguageBased target_name={"Rust"}>
```rust title="src/main.rs" lineNumbers=11
    if rng.gen() <= 0.8 {
        // [!code ++]
        println!("Simulating the handling of a specific failure");
        // [!code --]
        return Err(Arc::new("Complex real-world logic failed"));
    }
```
</RenderProgrammingLanguageBased>

Notice the foreshadowed **SHOULD** part? When a failure occurs <u>we should always be aware of</u>:
- What happened?
- When it happened?
- Why it happened?

This allows us to inspect the error and fully resolve it from somewhere else (given its resolvable). By silently ignoring
the error, we've made the promise to handle and resolve it ourselves the hard way.

Imagine there are hundreds of these failure points (example: division by zero, networking, databases), for every point, we have to
guarantee the error never exists but only success. This requires us to:
<ul>
    <li>Write boilerplate logic for every error.</li>
    <li>Going against one of the core philosophies of programming.</li>
    <li>Any bug in the handling of failure will silently cause other problems</li>
    <li>Confuses other developers using this TaskFrame</li>
    <RenderProgrammingLanguageBased target_name={"Rust"}>
        <li>Going against the type system of Rust</li>
    </RenderProgrammingLanguageBased>
</ul>
All in all, its better to leak this failure for us to patch it immediately than to silence it and let it cause havoc.

# Extracting Failure Out (Solution 2)
This is an upgrade to the previous solution. Instead of a monolithic business logic, we split every point of failure in steps,
these steps are the ones that can fail.

Whenever this happens we simply treat the error and try to resolve it, if we can't, we just give up and admit we failed.
Let's rewrite the code with this in mind:
<RenderProgrammingLanguageBased target_name={"Rust"}>
```rust title="src/main.rs" lineNumbers
use chronographer::prelude::*;
use std::sync::Arc;
use rand::prelude::*;

fn falliable_part() -> Result<(), TaskError> {
    let mut rng = rand::thread_rng();
    if rng.gen() <= 0.8 {
        return Err(Arc::new("Complex real-world logic failed"));
    }
}

#[task(interval = 3s)]
async fn mytask(ctx: &TaskContext) -> Result<(), TaskError> {
    println!("Simulating real-world complex unpredictable logic");
    let result = fallible_part();

    // Normally you would destructure the error to extract info from there
    if result.is_err() {
        println!("Simulating handling the failed part with some logic");
    }

    Ok(())
}

#[chronographer::main]
async fn main() {
    let task_inst = mytask();
    CHRONOGRAPHER_SCHEDULER.schedule(task_inst).await;
}
```
</RenderProgrammingLanguageBased>
This allows us to act upon those errors, and clearly signal our intent. To outside developers they immediately deduce
"``falliable_part`` <u>CAN</u> return an error and <u>SHOULD</u> be handled with care".

The resolving of this error is clear as well. However, the error may still leak through if its impossible to resolve it,
let's try more ways of resolving this error, such as adding retry logic:

<RenderProgrammingLanguageBased target_name={"Rust"}>
```rust title="src/main.rs" lineNumbers=15
    // [!code ++]
    let mut result: Result<(), TaskError> = Ok(());
    // [!code ++]
    for i in 0..5 {
        // [!code ++]
        result = fallible_part();
        // [!code --]
        let result = fallible_part();
        // [!code ++]
        if (result.is_ok()) break;
        // [!code ++]
        tokio::time::sleep(std::time::Duration::from_millis(100)).await;
    // [!code ++]
    }

    if result.is_err() {
        println!("Simulating handling the failed part with some logic");
    }
```
</RenderProgrammingLanguageBased>
What if we want to repeat this logic for 2 additional parts? Let's just do that:
<RenderProgrammingLanguageBased target_name={"Rust"}>
```rust title="src/main.rs" lineNumbers=15
    let mut result: : Result<(), TaskError> = Ok(());
    for i in 0..5 {
        result = fallible_part();
        if (result.is_ok()) break;
        tokio::time::sleep(std::time::Duration::from_millis(100)).await;
    }

    if result.is_err() {
        println!("Simulating handling the failed part (1) with some logic");
    }

    let mut result2: Result<(), TaskError> = Ok(());
    for i in 0..5 { // <-- Same number of retries
        result2 = fallible_part2(); // <-- Just different function used
        if (result2.is_ok()) break; // <-- Same break logic
        tokio::time::sleep(std::time::Duration::from_millis(100)).await; // <-- Same delay
    }

    if result2.is_err() {
        println!("Simulating handling the failed part (2) with some logic");
    }

    let mut result3: Result<(), TaskError> = Ok(());
    for i in 0..5 {
        result3 = fallible_part3();
        if (result3.is_ok()) break;
        tokio::time::sleep(std::time::Duration::from_millis(100)).await;
    }

    if result3.is_err() {
        println!("Simulating handling the failed part (3) with some logic");
    }
```
</RenderProgrammingLanguageBased>
This approach quickly leads to cumbersome / boilerplate writing. We have to manually copy paste stuff, if we make
such as the retry counter or delays, we have to reflect this throughout the code.

While the above can be solved with just a constant. However, there are other problems where it is not always simple,
an example of this is adding timeout logic.
<RenderProgrammingLanguageBased target_name={"Rust"}>
```rust title="src/main.rs" lineNumbers=15
    let handle = tokio::spawn(async {
        let mut result: Result<(), TaskError> = Ok(());
        for i in 0..5 {
            result = fallible_part();
            if (result.is_ok()) break;
            tokio::time::sleep(std::time::Duration::from_millis(100)).await;
        }

        result
    });
    tokio::select!(
        join_result = handle => {
            match join_result {
                Ok(inner_result) => {
                    if inner_result.is_err() {
                        println!("Simulating handling the failed part (1) with some logic");
                    }
                }

                Err(join_err) => {
                    println!("Task failed: {}", join_err);
                }
            }
        }

        _ = tokio::time::sleep(Duration::from_millis(700)) => {
            println!("Timeout occurred");
        }
    );

    // Same logic for the other 2
```
</RenderProgrammingLanguageBased>
This pattern scales poorly as the number of failure points grows (Try to move the timeout logic inside the retry, do it
in only one part).

One idea is to make these functions, which wrap inner functions. The higher functions provide the logic while the lower
ones do the pure business logic.

# The ChronoGrapher Way
This is the solution ChronoGrapher went with. It models workflows with simple primitives, however, unlike small brittle
higher-order functions, there are configurations for each primitive and plenty of them.

Unlike other schedulers, the main power is how these primitives aren't pinned in one place, one can move them
up or down, changing the entire logic completely.

Workflows will be discussed in detail, in the next chapter, we will take a look in how to use them and the many
other advantages that come with them. One teaser of them is:
<RenderProgrammingLanguageBased target_name={"Rust"}>
```rust title="src/main.rs" lineNumbers
// BEFORE: All that boilerplate
let mut result: Result<(), TaskError> = Ok(());
for i in 0..5 {
    result = fallible_part();
    if (result.is_ok()) break;
    tokio::time::sleep(std::time::Duration::from_millis(100)).await;
}

// AFTER: With ChronoGrapher's workflow model
#[workflow(retry(5, 100ms))]
async fn mytask(ctx: &TaskContext) -> Result<(), TaskError> {
    fallible_part()
}
```
</RenderProgrammingLanguageBased>

Workflows keep business logic pure & clean, without the need to manually handle those errors yourself,
while explicitly stating the recovery steps to make the code resilient.

> TL;DR. Handling failure in scheduling is a challenge. Solutions such as simply handling the error manually without the
error type or extracting each fallible step in a function are highly susceptible. ChronoGrapher however, makes it easy
and intuitive with its workflow model (simple primitives â†’ full-on workflows)