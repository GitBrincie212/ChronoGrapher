---
title: Inside The Scheduler
description: Continuation about ChronoGrapher's theory in the scheduler side
---

We have discussed one side of the coin (the theory). That being **Tasks**, let us explore the other being **Schedulers**,
this concept isn't interacted on a day-to-day basis, however, it is still a critical component and the backbone of ChronoGrapher.

# What Schedulers Handle (Clocks & Dispatching)

Schedulers do 4 things concurrently:
- They handle the storage of Tasks
- They coordinate multiple Tasks
- They emit each Task to execute the date they request
- They handle how the execution is handled (for efficiency and other reasons)

Just like Tasks, they have their own components, unlike Tasks however, they act globally on all Tasks they host, schedule
and coordinate. Specialized code can be run depending on how the Task is structured (we will cover in later chapters).

Usually these actions are abstracted away in the ``Scheduler`` methods, compared to developers needing to schedule Tasks,
these concepts mostly appeals to developers creating their own Scheduler.

The first composite of the Scheduler is the clock (``SchedulerClock``). It defines when is "now" and handles idling around,
the reason for this abstraction is depending on the environment, time acts differently.

For example in a testing setup, you might want deterministic time. Whereas in production, you want it to match real-world time.
The clock abstracts these details, letting the rest of the Scheduler focus on **what to do with Tasks rather than when to check**.

This leads to the second composite, that being the executor / dispatcher (``SchedulerTaskDispatcher``). It controls
how Tasks are executed.

It controls the environment it runs on, either be appending additional context in the Task, dispatching it in a thread pool or
silently watching. remember "Scheduling Policies" (or ``ScheduleStrategies``) from before? It uses them

---

# What Schedulers Handle (Storing & Coordination)

With the detour out of the way. A thought lingers "There can be lots of Tasks, we have to store them somewhere", this is
where the third composite enters the scene, i.e. Stores (``SchedulerTaskStore``).

They handle the storage of the Tasks, appending/deleting and modifying records, as well as the fetching the earliest Task
available. Depending on their implementation they can be <Highlight color={"neutral"}>Ephemeral</Highlight> or
<Highlight color={"info"}>Persistent</Highlight>, the difference will be clarified in a different chapter.

Now that we have covered all these three composites, what is the mechanism that coordinates all composites to work in
unison? The answer isn't the Scheduler composite, rather the engine (``SchedulerEngine``).

One can think engines as the brain and heart of the Scheduler. They handle the rescheduling process, fetching and
dispatching the earliest task, in addition having more functionality be laid on top (such a maximum run count enforcer).

---

# Configurations And The Bigger Picture
Schedulers are inherently more complex, as they manage storage, time-tracking, dispatching and coordination. Where each
is a separate composite, and together they form the Scheduler.

Since schedulers encapsulate all these composites, the scheduler must know what kind of components does it host. This
is where Scheduler Configurations (``SchedulerConfig``) come in.

They aren't a composite in the traditional sense, their job is to specify the components a Scheduler uses. Their reason
of existence is to prevent an inflation in generics.

They additionally allow one more ability which shall be discussed in later chapters, just keep in mind, they contain more
than just composites.

Now that we have observed from a bird's eye view the entire area of Schedulers, this diagram depicts how all composites work
together (including the configuration and the Scheduler):
<ThemeBasedImage
    light={"/diagram-light-3.svg"} dark={"/diagram-dark-3.svg"}
    width={1200} height={1200}
/>