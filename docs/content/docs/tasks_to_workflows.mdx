---
title: From Tasks To Workflows
description: Learn how to create Reliable Workflows from simple primitives
---
We have discussed in the previous chapter about **Inevitable Failure** (errors which are not recoverable) and its
various problems it poses, discussing in the way multiple solutions and ultimately ChronoGrapher's solution to this problem.

Workflows aren't just for handling failure, they are more powerful. One can execute multiple ``TaskFrames`` in sequence/parallel,
one can select dynamically one ``TaskFrame`` to execute and so on.

Returning to our previous script:
<RenderProgrammingLanguageBased target_name={"Rust"}>
```rust title="src/main.rs" lineNumbers
use chronographer::prelude::*;
use std::sync::Arc;
use rand::prelude::*;

#[task(interval = 3s)]
async fn mytask(ctx: &TaskContext) -> Result<(), TaskError> {
    println!("Simulating real-world complex unpredictable logic");
    let mut rng = rand::thread_rng();

    if rng.gen() <= 0.8 {
        println!("Real-world complex unpredictable logic failed");
        return Err(Arc::new("Complex real-world logic failed"));
    }
    println!("Real-world complex unpredictable logic succeeded");
    Ok(())
}

#[chronographer::main]
async fn main() {
    let task_inst = mytask();
    CHRONOGRAPHER_SCHEDULER.schedule(task_inst).await;
}
```
</RenderProgrammingLanguageBased>
<Callout type={"info"} title={"About the prints"}>
    We have added more prints to reflect the process of how the Task works, these are for learning purposes only.
</Callout>

## Retrying Our Task

Let's attempt to make ``mytask`` more secure by adding a retry mechanism with the number of retries being 5 and the
delay of each retry being 2 seconds:
<RenderProgrammingLanguageBased target_name={"Rust"}>
```rust title="src/main.rs" lineNumbers=5
#[task(interval = 3s)]
// [!code focus]
#[workflow(
    // [!code focus]
    retry(5, 2s)
// [!code focus]
)]
async fn mytask(ctx: &TaskContext) -> Result<(), TaskError> {
    // ...
}
```
</RenderProgrammingLanguageBased>
Running the code, you may notice something like this in the output:
```zsh title="terminal" lineNumbers
Simulating real-world complex unpredictable logic
Real-world complex unpredictable logic failed
# After 2 seconds (1st retry)
Simulating real-world complex unpredictable logic
Real-world complex unpredictable logic failed
# After 2 seconds (2nd retry)
Simulating real-world complex unpredictable logic
Real-world complex unpredictable logic succeeded
```
Sometimes you may notice even with plenty of retries, the Task can fail for all retries and still leak through.
Try changing the number of retries or the delay to something else and notice how it behaves.

## Fallbacks For Our Task
To fix this issue, we can define another Task as a fallback to this one via:
<RenderProgrammingLanguageBased target_name={"Rust"}>
```rust title="src/main.rs" lineNumbers=4
// [!code focus]
// [!code ++]
use tokio::time::{sleep, Duration};

// [!code focus]
// [!code ++]
// We tell ChronoGrapher to make it a TaskFrame only, not an entire Task
// [!code focus]
// [!code ++]
#[taskframe]
// [!code focus]
// [!code ++]
async fn mytask_fallback(ctx: &TaskContext) {
    // [!code focus]
    // [!code ++]
    println!("Simulating the resolving the error");
    // [!code focus]
    // [!code ++]

    // [!code focus]
    // [!code ++]
    sleep(Duration::from_millis(500)).await;
    // [!code focus]
    // [!code ++]

    // [!code focus]
    // [!code ++]
    println!("Resolved the error");
    // [!code focus]
    // [!code ++]
    Ok(())
// [!code focus]
// [!code ++]
}

#[task(interval = 3s)]
// [!code focus]
#[workflow(
    // [!code focus]
    retry(5, 2s),
    // [!code focus]
    // [!code ++]
    fallback(mytask_fallback)
    // [!code focus]
)]
async fn mytask(ctx: &TaskContext) -> Result<(), TaskError> {
    // ...
}
```
</RenderProgrammingLanguageBased>
Running the code, you may notice this difference:

```zsh title="terminal" lineNumbers
Simulating real-world complex unpredictable logic
Real-world complex unpredictable logic failed

# <...>

# After 2 seconds (5th retry)
Simulating real-world complex unpredictable logic
Real-world complex unpredictable logic failed
Simulating the resolving the error

# After 500ms

Resolved the error
```

If we really want, we can define more than one fallback like so:
<RenderProgrammingLanguageBased target_name={"Rust"}>
```rust title="src/main.rs" lineNumbers=4
#[task(interval = 3s)]
// [!code focus]
#[workflow(
    // [!code focus]
    retry(5, 2s),
    // [!code focus]
    // [!code highlight]
    fallback(mytask_fallback, my_other_fallback1, my_other_fallback2)
    // [!code focus]
)]
async fn mytask(ctx: &TaskContext) -> Result<(), TaskError> {
    // ...
}
```
</RenderProgrammingLanguageBased>

<Callout type={"error"} title={"Disclaimer About The Order Of The Workflow"}>
    The last workflow TaskFrame executes the first on top and wraps the entire workflow,
    the first workflow TaskFrame executes the last at the bottom and wraps only the ``mytask``.

    This means if we define our workflow as:
    <RenderProgrammingLanguageBased target_name={"Rust"}>
    ```rust
    #[workflow(
        retry(5, 2s),
        fallback(mytask_fallback)
    )]
    ```
    </RenderProgrammingLanguageBased>
    It is <Highlight color={"error"}>NOT</Highlight> the same as defining our workflow as:
    <RenderProgrammingLanguageBased target_name={"Rust"}>
    ```rust
    #[workflow(
        fallback(mytask_fallback),
        retry(5, 2s)
    )]
    ```
    </RenderProgrammingLanguageBased>
    The former **executes the retries** and when all retries failed **THEN the fallback**. Whereas the latter **executes the
    fallback for every failure** and **THEN once everything fails, a retry occurs**.
</Callout>

## Defining A Deadline For Our Task
Currently, our workflow may run for an infinite time, potentially hanging indefinitely. To fix this we can define
a timeout with the maximum time allowed being 6 seconds:
<RenderProgrammingLanguageBased target_name={"Rust"}>
```rust title="src/main.rs" lineNumbers=5
#[task(interval = 3s)]
// [!code focus]
#[workflow(
    // [!code focus]
    retry(5, 2s),
    // [!code focus]
    fallback(mytask_fallback),
    // [!code focus]
    // [!code ++]
    timeout(6s)
    // [!code focus]
)]
async fn mytask(ctx: &TaskContext) -> Result<(), TaskError> {
    // ...
}
```
</RenderProgrammingLanguageBased>
We notice in the output:

```zsh title="terminal" lineNumbers
Simulating real-world complex unpredictable logic
Real-world complex unpredictable logic failed

# <...>

# [!code --]
# After 2 seconds (3rd retry, was about to execute but got interrupted)
# [!code --]
  | Simulating real-world complex unpredictable logic
# [!code --]
  | Real-world complex unpredictable logic failed
# [!code --]
  | Simulating the resolving the error

> Scheduler logs the timeout error from this Task
# ...
```


When the workflow exceeds the maximum deadline, it fully cancels the workflow and throws a timeout error. Experiment by
changing the maximum deadline of the timeout to a larger number.
<RenderProgrammingLanguageBased target_name={"Rust"}>
<Callout type={"error"} title={"Limitations Of Timeout"}>
    Due rust's async model (cooperative cancelling), when a timeout occurs, it doesn't cancel immediately,
    it only happens when an async point is hit. This means the workflow may fully complete even if a timeout error is thrown.

    For async-heavy tasks, this is a non-issue. For tasks that are CPU-blocking most of the time, the solution is to yield
    on specific points throughout your code (not too much though, for performance reasons)
</Callout>
</RenderProgrammingLanguageBased>

## Delaying Our Task
We may want to delay the execution of our workflow, say for one full second. We can model like so:
<RenderProgrammingLanguageBased target_name={"Rust"}>
```rust title="src/main.rs" lineNumbers=5
#[task(interval = 3s)]
// [!code focus]
#[workflow(
    // [!code focus]
    retry(5, 2s),
    // [!code focus]
    fallback(mytask_fallback),
    // [!code focus]
    timeout(10s),
    // [!code focus]
    // [!code ++]
    delay(1s)
// [!code focus]
)]
async fn mytask(ctx: &TaskContext) -> Result<(), TaskError> {
    // ...
}
```
</RenderProgrammingLanguageBased>
Yet again our output differs slightly:
```zsh title="terminal" lineNumbers
# After one full second
Simulating real-world complex unpredictable logic
Real-world complex unpredictable logic failed

# <...>
```